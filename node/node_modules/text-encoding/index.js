// Browser-compatible TextDecoder/TextEncoder
// Export native browser TextDecoder/TextEncoder or provide polyfill

let TextDecoderClass, TextEncoderClass;

if (typeof globalThis !== 'undefined' && globalThis.TextDecoder && globalThis.TextEncoder) {
  // Modern browser with native support
  TextDecoderClass = globalThis.TextDecoder;
  TextEncoderClass = globalThis.TextEncoder;
} else if (typeof window !== 'undefined' && window.TextDecoder && window.TextEncoder) {
  // Browser window object
  TextDecoderClass = window.TextDecoder;
  TextEncoderClass = window.TextEncoder;
} else if (typeof self !== 'undefined' && self.TextDecoder && self.TextEncoder) {
  // Web Worker context
  TextDecoderClass = self.TextDecoder;
  TextEncoderClass = self.TextEncoder;
} else {
  // Polyfill fallback
  TextDecoderClass = class TextDecoder {
    constructor(encoding = 'utf-8') {
      this.encoding = encoding;
    }
    
    decode(input) {
      if (input instanceof ArrayBuffer) {
        input = new Uint8Array(input);
      }
      if (input instanceof Uint8Array) {
        let str = '';
        for (let i = 0; i < input.length; i++) {
          str += String.fromCharCode(input[i]);
        }
        try {
          return decodeURIComponent(escape(str));
        } catch (e) {
          return str;
        }
      }
      return String(input);
    }
  };
  
  TextEncoderClass = class TextEncoder {
    constructor() {
      this.encoding = 'utf-8';
    }
    
    encode(input) {
      const str = String(input);
      const bytes = new Uint8Array(str.length);
      for (let i = 0; i < str.length; i++) {
        bytes[i] = str.charCodeAt(i);
      }
      return bytes;
    }
  };
}

module.exports = {
  TextDecoder: TextDecoderClass,
  TextEncoder: TextEncoderClass
};
